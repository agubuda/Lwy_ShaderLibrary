// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel meshModifier
#pragma kernel skinnedMeshModifier
#pragma kernel InitializeMesh
#pragma kernel InitializeSkinnedMesh

// --- Data Structures ---

struct cacheData {
    float3 prevPosWS;
    float3 velocityWS;
    float3 dPoseWS;
};

struct skinnedMeshBuffer {
    float3 position;
    float3 tangent;
    float2 uv1;
    float2 uv2;
};

// Max 8 neighbors per vertex
struct NeighborData {
    int count;
    int indices[8];
    float restLengths[8];
};

// --- Variables ---

float4x4 _LocalToWorld;

uint vertCount;
float _MoveScale;
float _Spring;      
float _Damper;      
float _DeltaTime;

// Cloth Specific settings
float _ClothStiffness; 

// Stability settings
float _MaxVelocity; // Max speed allowed per frame (prevents explosion)
float _MaxDeviation; // Max distance from prediction allowed

RWStructuredBuffer<float4> _VertexColor;
RWStructuredBuffer<float3> _pos; 
RWStructuredBuffer<cacheData> data; 

// For Static Meshes
StructuredBuffer<float3> _InputPositions; 

// For Skinned Meshes
RWStructuredBuffer<skinnedMeshBuffer> _skinnedPos;

// Neighbor Info (Read Only)
StructuredBuffer<NeighborData> _NeighborBuffer;

// --- Helper Functions ---

float3 CalculateTargetPos(float3 localPos)
{
    return mul(_LocalToWorld, float4(localPos, 1.0)).xyz;
}

// --- Initialization Kernels ---

[numthreads(128, 1, 1)]
void InitializeMesh(uint3 id : SV_DispatchThreadID) {
    if (id.x >= vertCount) return;

    float3 targetPosWS = CalculateTargetPos(_InputPositions[id.x]);

    _pos[id.x] = targetPosWS;
    data[id.x].prevPosWS = targetPosWS;
    data[id.x].velocityWS = float3(0, 0, 0);
    data[id.x].dPoseWS = float3(0, 0, 0);
}

[numthreads(128, 1, 1)]
void InitializeSkinnedMesh(uint3 id : SV_DispatchThreadID) {
    if (id.x >= vertCount) return;

    float3 targetPosWS = CalculateTargetPos(_skinnedPos[id.x].position);

    _pos[id.x] = targetPosWS;
    data[id.x].prevPosWS = targetPosWS;
    data[id.x].velocityWS = float3(0, 0, 0);
    data[id.x].dPoseWS = float3(0, 0, 0);
}

// --- Physics Logic ---

float3 CalculateSpringForces(uint index, float3 currentPos, float3 targetPos, float3 velocity)
{
    // 1. Goal Matching
    float3 displacement = targetPos - currentPos;
    float3 goalForce = _Spring * displacement;

    // 2. Structural Springs (Neighbors)
    float3 neighborForce = float3(0,0,0);
    NeighborData nData = _NeighborBuffer[index];
    
    for(int i = 0; i < nData.count; i++)
    {
        int nIndex = nData.indices[i];
        float restLen = nData.restLengths[i];
        
        float3 nPos = data[nIndex].prevPosWS; 
        
        float3 dir = nPos - currentPos;
        float dist = length(dir);
        
        if(dist > 0.0001)
        {
            float3 dirNorm = dir / dist;
            float stretch = dist - restLen;
            neighborForce += dirNorm * stretch * _ClothStiffness;
        }
    }

    // 3. Damping
    float3 dampForce = velocity * -_Damper;

    return goalForce + neighborForce + dampForce;
}

// --- Update Kernels ---

[numthreads(128, 1, 1)]
void skinnedMeshModifier(uint3 id : SV_DispatchThreadID) {
    if (id.x >= vertCount) return;

    // 1. Target Data
    float3 targetPosWS = CalculateTargetPos(_skinnedPos[id.x].position);
    float weight = _VertexColor[id.x].r;

    // Optimization: Skip calculation for rigid parts
    if (weight < 1e-3) {
        _pos[id.x] = targetPosWS;
        data[id.x].prevPosWS = targetPosWS;
        data[id.x].velocityWS = float3(0,0,0);
        return;
    }

    // Safety: Reset on Teleport
    if (distance(data[id.x].prevPosWS, targetPosWS) > 2.0) {
        data[id.x].prevPosWS = targetPosWS;
        data[id.x].velocityWS = float3(0,0,0);
    }

    // 2. Prediction (Kalman-lite)
    // Based on previous velocity, guess where we should be
    float dt = clamp(_DeltaTime, 0.0, 0.05);
    float3 currentPosWS = data[id.x].prevPosWS;
    float3 predictedPos = currentPosWS + data[id.x].velocityWS * dt;

    // 3. Physics Solve
    float3 forceWS = CalculateSpringForces(id.x, currentPosWS, targetPosWS, data[id.x].velocityWS);
    
    // Update Velocity
    float3 newVelocity = data[id.x].velocityWS + forceWS * dt;
    
    // Velocity Cap (Stability)
    // Prevent velocity from exploding (e.g. max 10m/s)
    float maxVel = 10.0; 
    float velLen = length(newVelocity);
    if (velLen > maxVel) {
        newVelocity = (newVelocity / velLen) * maxVel;
    }

    // Calculate Proposed Position
    float3 nextPosWS = currentPosWS + newVelocity * dt;

    // 4. Constraint: Prediction Clamp (Anti-Jitter / Anti-Pop)
    // Instead of multi-frame averaging, we limit how far we can deviate from our "momentum prediction".
    // This effectively filters out high-frequency noise (physics explosions).
    float3 deviationFromPrediction = nextPosWS - predictedPos;
    float devLen = length(deviationFromPrediction);
    
    // Allow some deviation (physics happening), but clamp extreme jumps
    // The threshold can be dynamic, but 0.1m per frame deviation is usually plenty.
    float maxDev = 0.1; 
    if (devLen > maxDev) {
        // Smoothly pull back to prediction
        nextPosWS = predictedPos + (deviationFromPrediction / devLen) * maxDev;
        // Correct velocity to match the clamped position (conserve energy conservation roughly)
        newVelocity = (nextPosWS - currentPosWS) / (dt + 1e-5); 
    }

    // 5. Update State
    data[id.x].velocityWS = newVelocity;
    data[id.x].prevPosWS = nextPosWS;

    // 6. Render Output Blend
    float3 dPoseWS = (nextPosWS - targetPosWS);
    float moveLen = length(dPoseWS);
    float maxDeviation = 0.5; // Visual max stretch constraint
    if(moveLen > maxDeviation) {
        dPoseWS = (dPoseWS / moveLen) * maxDeviation;
    }

    float blendFactor = weight * _MoveScale;
    float3 finalPos = targetPosWS + dPoseWS * blendFactor;
    
    _pos[id.x] = finalPos;
}

[numthreads(128, 1, 1)]
void meshModifier(uint3 id : SV_DispatchThreadID) {
    if (id.x >= vertCount) return;

    float3 targetPosWS = CalculateTargetPos(_InputPositions[id.x]);
    float weight = _VertexColor[id.x].r;

    if (weight < 1e-3) {
        _pos[id.x] = targetPosWS;
        data[id.x].prevPosWS = targetPosWS;
        data[id.x].velocityWS = float3(0,0,0);
        return;
    }

    if (distance(data[id.x].prevPosWS, targetPosWS) > 2.0) {
        data[id.x].prevPosWS = targetPosWS;
        data[id.x].velocityWS = float3(0,0,0);
    }

    float dt = clamp(_DeltaTime, 0.0, 0.05);
    float3 currentPosWS = data[id.x].prevPosWS;
    float3 predictedPos = currentPosWS + data[id.x].velocityWS * dt;

    float3 forceWS = CalculateSpringForces(id.x, currentPosWS, targetPosWS, data[id.x].velocityWS);
    
    float3 newVelocity = data[id.x].velocityWS + forceWS * dt;
    float maxVel = 10.0; 
    float velLen = length(newVelocity);
    if (velLen > maxVel) {
        newVelocity = (newVelocity / velLen) * maxVel;
    }

    float3 nextPosWS = currentPosWS + newVelocity * dt;

    float3 deviationFromPrediction = nextPosWS - predictedPos;
    float devLen = length(deviationFromPrediction);
    float maxDev = 0.1; 
    if (devLen > maxDev) {
        nextPosWS = predictedPos + (deviationFromPrediction / devLen) * maxDev;
        newVelocity = (nextPosWS - currentPosWS) / (dt + 1e-5); 
    }

    data[id.x].velocityWS = newVelocity;
    data[id.x].prevPosWS = nextPosWS;

    float3 dPoseWS = (nextPosWS - targetPosWS);
    float moveLen = length(dPoseWS);
    float maxDeviation = 0.5;
    if(moveLen > maxDeviation) {
        dPoseWS = (dPoseWS / moveLen) * maxDeviation;
    }

    float blendFactor = weight * _MoveScale;
    float3 finalPos = targetPosWS + dPoseWS * blendFactor;
    
    _pos[id.x] = finalPos;
}