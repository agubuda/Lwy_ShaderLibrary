// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel meshModifier
#pragma kernel skinnedMeshModifier
#pragma kernel InitializeMesh
#pragma kernel InitializeSkinnedMesh

// --- Data Structures ---

struct cacheData {
    float3 prevPosWS;
    float3 velocityWS;
    float3 dPoseWS;
};

struct skinnedMeshBuffer {
    float3 position;
    float3 tangent;
    float2 uv1;
    float2 uv2;
};

struct NeighborData {
    int count;
    int indices[8];
    float restLengths[8];
};

struct VertexTriangleMap {
    int count;
    int tIndices[12];
};

struct Triangle {
    int v0, v1, v2;
};

// --- Variables ---

float4x4 _LocalToWorld;

uint vertCount;
float _MoveScale;
float _Spring;      
float _Damper;      
float _DeltaTime;
float _ClothStiffness; 
int _RecalculateNormals; // Switch

RWStructuredBuffer<float4> _VertexColor;
RWStructuredBuffer<float3> _pos; 
RWStructuredBuffer<float3> _normals; 
RWStructuredBuffer<cacheData> data; 

// Inputs
StructuredBuffer<float3> _InputPositions; 
StructuredBuffer<float3> _InputNormals; 

// Skinned
RWStructuredBuffer<skinnedMeshBuffer> _skinnedPos;

// Topology
StructuredBuffer<NeighborData> _NeighborBuffer;
StructuredBuffer<Triangle> _TriangleBuffer;
StructuredBuffer<VertexTriangleMap> _VertexTriangleMap;

// --- Helper Functions ---

float3 CalculateTargetPos(float3 localPos)
{
    return mul(_LocalToWorld, float4(localPos, 1.0)).xyz;
}

// --- High Quality Geometry Normal Recalculation ---
float3 RecalculateNormalGeometry(uint index)
{
    float3 smoothNormal = float3(0,0,0);
    VertexTriangleMap map = _VertexTriangleMap[index];
    
    // Accumulate face normals from surrounding triangles
    for(int i = 0; i < map.count; i++)
    {
        int triIndex = map.tIndices[i];
        Triangle tri = _TriangleBuffer[triIndex];
        
        float3 p0 = _pos[tri.v0];
        float3 p1 = _pos[tri.v1];
        float3 p2 = _pos[tri.v2];
        
        // Face Normal = cross(edge1, edge2)
        // Area weighted naturally by cross product magnitude
        float3 faceNormal = cross(p1 - p0, p2 - p0);
        smoothNormal += faceNormal;
    }
    
    // If no triangles (detached vertex) or degenerate, fallback
    if (length(smoothNormal) < 1e-6) return float3(0,1,0);

    return normalize(smoothNormal);
}

// --- Initialization Kernels ---

[numthreads(128, 1, 1)]
void InitializeMesh(uint3 id : SV_DispatchThreadID) {
    if (id.x >= vertCount) return;

    float3 targetPosWS = CalculateTargetPos(_InputPositions[id.x]);

    _pos[id.x] = targetPosWS;
    _normals[id.x] = float3(0,1,0); 
    data[id.x].prevPosWS = targetPosWS;
    data[id.x].velocityWS = float3(0, 0, 0);
    data[id.x].dPoseWS = float3(0, 0, 0);
}

[numthreads(128, 1, 1)]
void InitializeSkinnedMesh(uint3 id : SV_DispatchThreadID) {
    if (id.x >= vertCount) return;

    float3 targetPosWS = CalculateTargetPos(_skinnedPos[id.x].position);

    _pos[id.x] = targetPosWS;
    _normals[id.x] = float3(0,1,0);
    data[id.x].prevPosWS = targetPosWS;
    data[id.x].velocityWS = float3(0, 0, 0);
    data[id.x].dPoseWS = float3(0, 0, 0);
}

// --- Physics Logic ---

float3 CalculateSpringForces(uint index, float3 currentPos, float3 targetPos, float3 velocity)
{
    float3 displacement = targetPos - currentPos;
    float3 goalForce = _Spring * displacement;

    float3 neighborForce = float3(0,0,0);
    NeighborData nData = _NeighborBuffer[index];
    
    for(int i = 0; i < nData.count; i++)
    {
        int nIndex = nData.indices[i];
        float restLen = nData.restLengths[i];
        float3 nPos = data[nIndex].prevPosWS; 
        
        float3 dir = nPos - currentPos;
        float dist = length(dir);
        
        if(dist > 0.0001)
        {
            float3 dirNorm = dir / dist;
            float stretch = dist - restLen;
            neighborForce += dirNorm * stretch * _ClothStiffness;
        }
    }

    float3 dampForce = velocity * -_Damper;
    return goalForce + neighborForce + dampForce;
}

// --- Update Kernels ---

[numthreads(128, 1, 1)]
void skinnedMeshModifier(uint3 id : SV_DispatchThreadID) {
    if (id.x >= vertCount) return;

    float3 targetPosWS = CalculateTargetPos(_skinnedPos[id.x].position);
    
    // For rigid parts or if recalc is off, use transformed static normal
    // Note: We don't have skinned normal buffer bound here easily without another buffer copy.
    // So for skinned meshes, if recalc is OFF, we might have static looking normals unless we pass skinned normals.
    // Assuming user wants quality on skinned mesh, geometry recalc is best.
    float3 refNormal = float3(0,1,0); 

    float weight = _VertexColor[id.x].r;

    if (weight < 1e-3) {
        _pos[id.x] = targetPosWS;
        data[id.x].prevPosWS = targetPosWS;
        data[id.x].velocityWS = float3(0,0,0);
        
        if (_RecalculateNormals) _normals[id.x] = RecalculateNormalGeometry(id.x);
        else _normals[id.x] = float3(0,1,0); // Fallback / Static
        return;
    }

    if (distance(data[id.x].prevPosWS, targetPosWS) > 2.0) {
        data[id.x].prevPosWS = targetPosWS;
        data[id.x].velocityWS = float3(0,0,0);
    }

    float dt = clamp(_DeltaTime, 0.0, 0.05);
    float3 currentPosWS = data[id.x].prevPosWS;
    float3 predictedPos = currentPosWS + data[id.x].velocityWS * dt;

    float3 forceWS = CalculateSpringForces(id.x, currentPosWS, targetPosWS, data[id.x].velocityWS);
    
    float3 newVelocity = data[id.x].velocityWS + forceWS * dt;
    
    float maxVel = 10.0; 
    float velLen = length(newVelocity);
    if (velLen > maxVel) newVelocity = (newVelocity / velLen) * maxVel;

    float3 nextPosWS = currentPosWS + newVelocity * dt;

    float3 deviationFromPrediction = nextPosWS - predictedPos;
    float devLen = length(deviationFromPrediction);
    
    float maxDev = 0.1; 
    if (devLen > maxDev) {
        nextPosWS = predictedPos + (deviationFromPrediction / devLen) * maxDev;
        newVelocity = (nextPosWS - currentPosWS) / (dt + 1e-5); 
    }

    data[id.x].velocityWS = newVelocity;
    data[id.x].prevPosWS = nextPosWS;

    float3 dPoseWS = (nextPosWS - targetPosWS);
    float moveLen = length(dPoseWS);
    float maxDeviation = 0.5; 
    if(moveLen > maxDeviation) {
        dPoseWS = (dPoseWS / moveLen) * maxDeviation;
    }

    float blendFactor = weight * _MoveScale;
    float3 finalPos = targetPosWS + dPoseWS * blendFactor;
    
    _pos[id.x] = finalPos;
    
    // Normal Output
    if (_RecalculateNormals) {
        _normals[id.x] = RecalculateNormalGeometry(id.x);
    } else {
        // Fallback for performance: Just use Up or maybe a rough approximation
        _normals[id.x] = float3(0,1,0); 
    }
}

[numthreads(128, 1, 1)]
void meshModifier(uint3 id : SV_DispatchThreadID) {
    if (id.x >= vertCount) return;

    float3 targetPosWS = CalculateTargetPos(_InputPositions[id.x]);
    float3 staticNormal = mul((float3x3)_LocalToWorld, _InputNormals[id.x]);
    staticNormal = normalize(staticNormal);

    float weight = _VertexColor[id.x].r;

    if (weight < 1e-3) {
        _pos[id.x] = targetPosWS;
        data[id.x].prevPosWS = targetPosWS;
        data[id.x].velocityWS = float3(0,0,0);
        
        // Rigid parts should follow rotation
        _normals[id.x] = staticNormal;
        return;
    }

    if (distance(data[id.x].prevPosWS, targetPosWS) > 2.0) {
        data[id.x].prevPosWS = targetPosWS;
        data[id.x].velocityWS = float3(0,0,0);
    }

    float dt = clamp(_DeltaTime, 0.0, 0.05);
    float3 currentPosWS = data[id.x].prevPosWS;
    float3 predictedPos = currentPosWS + data[id.x].velocityWS * dt;

    float3 forceWS = CalculateSpringForces(id.x, currentPosWS, targetPosWS, data[id.x].velocityWS);
    
    float3 newVelocity = data[id.x].velocityWS + forceWS * dt;
    float maxVel = 10.0; 
    float velLen = length(newVelocity);
    if (velLen > maxVel) newVelocity = (newVelocity / velLen) * maxVel;

    float3 nextPosWS = currentPosWS + newVelocity * dt;

    float3 deviationFromPrediction = nextPosWS - predictedPos;
    float devLen = length(deviationFromPrediction);
    float maxDev = 0.1; 
    if (devLen > maxDev) {
        nextPosWS = predictedPos + (deviationFromPrediction / devLen) * maxDev;
        newVelocity = (nextPosWS - currentPosWS) / (dt + 1e-5); 
    }

    data[id.x].velocityWS = newVelocity;
    data[id.x].prevPosWS = nextPosWS;

    float3 dPoseWS = (nextPosWS - targetPosWS);
    float moveLen = length(dPoseWS);
    float maxDeviation = 0.5;
    if(moveLen > maxDeviation) {
        dPoseWS = (dPoseWS / moveLen) * maxDeviation;
    }

    float blendFactor = weight * _MoveScale;
    float3 finalPos = targetPosWS + dPoseWS * blendFactor;
    
    _pos[id.x] = finalPos;
    
    // Normal Output
    if (_RecalculateNormals) {
        _normals[id.x] = RecalculateNormalGeometry(id.x);
    } else {
        _normals[id.x] = staticNormal;
    }
}